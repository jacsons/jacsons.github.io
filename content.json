{"meta":{"title":"jacsons","subtitle":"read, leaning, thinking, conclusion","description":null,"author":"jacsons","url":"http://www.jacsons.com","root":"/"},"posts":[{"tags":[{"name":"conclusion","slug":"conclusion","permalink":"http://www.jacsons.com/tags/conclusion/"},{"name":"thingking","slug":"thingking","permalink":"http://www.jacsons.com/tags/thingking/"}],"title":"底层软件项目管理的思考","date":"2020/02/02","text":"背景因前段时间项目经理收集项目中存在的短板与建议项，就提了一条。但是，这些短板在工作之中就已经发现，但是一直只是在私下吐槽，一直没有像上反馈。主要考虑到底层与通过软件的区别以及这些政策条件不成熟。现把这些想法写下来，其实是以往通用软件工作经验与底层软件经验结合后的一些项目管理上的思考。 成员构成 经验作为研发，项目都是由人来完成，人力资源是最重要的资源。但是，并不是具备某些知识就可以，经验也很重要，特别是底层软件，常存在难于排查问题，此时经验往往能够节省成周成月的费用。 知识更新另外随着软件的发展，底层软件仍然使用的是面向过程的C语言（就linux系统），但原来的那套知识构成的人员，已经慢慢的不适应当前的软件规模开发，急需对知识进行扩充与更新了。更新包括需要有面向对象的思想来编写C语言，同时需要有上层软件开发软件的工程化思维，才能应对当前快速大规模的软件开发模式了。 人员组成 迭代模式需要开发、测试、项目组织、SE、项目经理需要迭代前的规划、迭代过程共同努力，而不是仅仅只有开发参与。当前项目正从瀑布开发模型向迭代模式进行转型，当前有点类似于三不像阶段，既不向瀑布模型又不像迭代模型，有迭代的外壳（按照月进行），任务却是有什么功能需要就开发什么，测试也是等开发编码完成后，测试上一轮的功能，有点测试与开发脱节的味道,SE参与全局性的规范，项目经理关注项目进度，没有注重关注到项目之间信息的即时性。 组织结构组织结构是项目的基本，决定着项目的成功与失败。好的软件与坏的软件其实从组织结构设计开始就已经确定了，然而组织与软件开发一样，不可能从刚刚开始就已成熟了，而是通过反复迭代走向成熟的。如同软件一样，前期一定要有清晰的目标，在软件周期过程中持续的更新变化以应对软件开发过程。个人认为一个成熟的软件开发团队组成如下。 作为一个组织结构应当含有以下成员 开发负责人 作为整个项目负责人与资源管理者，需要对资源进行合理的分配，把握项目的整体进度与方向，需要知道要做什么，什么不能做。同时需要了解项目组的问题点与低效率点，并且提供资源这些问题进行补齐，这将极高团队的效率。 人力资源负责人 作为人力资源负责人，需要识别团队人力资源方面的短板，招聘或者制定培养计划提升团队的能力、能力储备、团队活跃工作。 项目经理 一个开发团队可能会有多个项目组成，项目与项目之间如果存在关联关系时，就需要项目经理这一角色。项目经理的职责属于拉通团队与团队之间，项目组与开发负责人之间桥梁的工作。 系统架构师（SA） 架构师主要是关注软件的架构，当软件规模的持续变大时，需要架构师设计出满足当前软件的架构模式，需要结合人力组成与软件性能要求，设计出满足当前人力资源情况的软件框架。同时需要对模块间的接口，公共组件、第三方软件、骨架进行管理与维护，并能够参与其中。 P.S: 该职责人员其实是相当重要的，但是目前底软开发团队中缺少此角色，以及组织模式导致当前功能模块之间一个一个处于孤立状态，模块内功能重复编写，增大了程序的复杂度，也导致了极其难以维护。 系统工程师（SE） 系统工程师的职责是对业务面的需求转换为功能方面需求进行分析设计。特别需要分析出业务之间的依赖关系，对于被依赖的功能一定要提前安排完成。 P.S：一定要建立好需求记录表格。另外对依赖关系需要梳理好，被依赖提前规划。（正式因为这个原因，当前项目常常出现功能开发被另外一个功能所阻塞） 开发团队 开发作为功能开发团队，也涵盖开发组长、MDE、开发人员。组长作为leader应当涵盖开发负责人、项目经理的角色：设别团队短板、跟踪项目内的进度难度与项目外事务的拉通工作。 P.S： 需要了解整个项目的功能，并且识别项目中的短板，预留能力重构短板。这一块将会对整个团队工作舒适度会有极大的改善。 测试团队 测试作为功能的保障团队，需要对交付出去的功能进行负责。当前的软件规模越来越大，需要测试人员需要编写自动化程序的能力，利用测试化框架持续保障系统功能。 质量团队（QA） 质量人员主要关注项目组各模块的质量状况，可以从问题数、构建数失败数、线上问题数、静态告警等维度去统计各组质量情况。如果有条件可以组织检视各项目团队的代码，通过分析其中的安全问题、基本问题等角度来度量各模块的质量，为项目决策者识别项目中的短板及时补齐。同时也可以编写经典案例进行分享，提升团队质量意识。 P.S：如果团队不大，没有必要存在专门的团队来负责这一块。可以通过指定负责人与部分开发人员组成临时的团队来处理此职责。 资料与秘书团队 资料与秘书团队主要负责项目中的资料的整理（编写有开发完成），秘书主要负责项目组中的一些零碎性的事务。如果有条件，其实可以每个项目组就存在一个类似的人员。 P.S：如果团队不大，没有必要存在专门的团队来负责这一块。可以通过指定负责人与部分开发人员组成临时的团队来处理此职责。 项目活动规划设计项目规划对整个项目进行非常重要，常常一个简单政策将会很大程度的影响到项目的工作量，甚至是人员的稳定性，这个往往不是一篇文章能够描述完成的。此处为工作者几年来观察，工作产出大， 组织结构 软件框架 项目的软件是一个整体，各个模块之间不能够分割来编写，这样会因公共部分重复编写导致重复工作问题，另外也会每个人员技能不能，出现软件质量腐烂。故软件框架需要区分功能部分与基本模块部分，骨干部分与枝叶部分。 必要会议 CCB 会议 决策项目的资源分配、框架接口等各种项目的公共事务部分。 安全会议 决策安全方面的问题：如接口，安全评审以及静态告警方面的屏蔽。 小组例会 汇报小组项目进度，识别风险点与组内组间的述求。 开发流程当前的开发都已基于svn或者git来进行版本控制，建议使用git来做版本控制，具体可以通过网上获取git与svn相对的优点。 前期准备 拉迭代分支 SE 前期分析出本迭代中存在的依赖的功能模块。 开发过程 1、开发进行需求分析，输出分析文档（资料对此进行收集与汇总） 2、编码 此阶段主要完成编码工作，同时在开发过程。 3、中期对齐 4、测试 &amp; 问题单 5、代码合如 &amp; 修复合入导致的问题 中间过程 中间过程在开发的2/3时，与测试对齐，测试启动测试程序开发，作为开发与测试共同功能验证点. 奖惩措施 对项目组内合入的需求的问题进行统计，根据问题难度与问题数进行权重汇总，得到一个得分进行排序。 1、对于问题少的人，记录问题考核点。 2、对于出错问题多的人，加强质量意识。如参与静态检查工作、测试工作等。 3、挑出项目组中问题较多点或者代码优秀点，在项目组例会上进行分享，并且作为个人绩效参考点。 优秀点commit机制项目组实行commiter机制，指定模块特别熟悉的人作为commiter，在代码何如时进行审核。从项目运行的经历看，能够很好的提升代码何如质量。","permalink":"http://www.jacsons.com/2020/02/02/总结/思考/底层软件项目管理的思考/","photos":[]},{"tags":[{"name":"conclusion","slug":"conclusion","permalink":"http://www.jacsons.com/tags/conclusion/"},{"name":"tools","slug":"tools","permalink":"http://www.jacsons.com/tags/tools/"},{"name":"samba","slug":"samba","permalink":"http://www.jacsons.com/tags/samba/"}],"title":"ubuntu创建共享目录给windows","date":"2020/02/02","text":"ubuntu创建共享目录给windows下载samba sudo apt-get install samba sudo apt-get install smbclient 检查版本： samba -V 配置 sudo vi /etc/samba/smb.conf 加入配置信息 [share] comment = share folder browseable = yes path = /home/sophia/ //需要共享的目录，要确保该文件存在，不存在后面创建该目录 create mask = 0777 directory mask = 0777 valid users = sophia //用户名 force user = sophia // 此处配置的是在windos下创建文件时新建文件所属的用户，一定要配置，否则linux和windows用户不一致会出现。 force group = sophia // 此处配置的是在windos下创建文件时新建文件所属的用户组，一定要配置，否则linux和windows用户不一致会出现。 public = yes available = yes 给用户添加密码sudo smbpasswd -a zhang 重启samba sudo /etc/init.d/samba restart 其他命令查看samba服务器中已拥有哪些用户： pdbedit -L 删除samba服务中的某个用户 smbpasswd -x 用户名 参考文档：https://jingyan.baidu.com/article/3a2f7c2ed314ef26afd611a1.html","permalink":"http://www.jacsons.com/2020/02/02/总结/工具/samba配置/","photos":[]},{"tags":[{"name":"year-plan","slug":"year-plan","permalink":"http://www.jacsons.com/tags/year-plan/"}],"title":"2020年度计划","date":"2020/01/15","text":"年度计划原本打算元旦就将年度计划写下，结果拖拖拉拉又拖到了15，看样子今年的最大年度目标是解决拖拉的习惯了，不管怎样路是一步一步走出来的，路走之前，计划先行，再晚也得把计划写下来，同时自己也要坚持，坚持！ 阅读计划目标 一个月一本技术类书籍，并且每本书最少写一个总结，像比较大类的书写一个系列的文章，目前已经排上日程的书单如下： 清单 序列 书名 完成时间 系列文章 状态 1 debug hacks 1月30日 100% 2 32位嵌入式系统与soc设计导论 2月28日 100% 3 待定 100% 4 待定 100% 5 待定 课外阅读 视频 工作晚上回来很累，视频是此时最好的学习方式，故每周最少保持3个晚上看视频半小时以上。 序列 任务 完成时间 状态 1 ARM视频第一期与第二期衔接 2月28日 60% 2 ARM视频第二期 5月01日 未开始 3 ARM视频第三期 10月01日 未开始 4 待定 项目目标 本年度的项目目标是编译一个能运行于host/device端通信与状态查询的软件框架，要具有稳定性与可移植性，整体参照视频学习与工作项目来编写。 序列 任务 完成时间 状态 1 uboot设计与编写 2月28日 20% 2 系统结构设计与编写 待定 技术博客目标博客目标是提升对日程学习生活的积累与沉淀，提升自己的表达能力。本年的目标是能够有初步规范的软件分析设计的能力，其中包括目标的设定，软件结构的分析与需求的分解，软件实现的能力。 序列 任务 完成时间 状态 1 C设计模式（预计20篇）博客编写 3月31日 10% 2 Linux 系统学习文档编写 6月1日 3 每月一项目技术总结 全年 4 工具类与效率类方法总结 全年 5 待定 运动目标运动的目标是保持身心健康，同时改变自己的偏内向性格，提升自己的自信。故今年的目标是参加一个团体性活动，能够保持 一月一团体活动 的参与量的目力。现制定目标如下： 1、一月一团体性活动参与量。 2、夏天：每周3次健身房。 家庭目标升级为爸爸，需要为家庭做出榜样，同时也要花时间为家庭做出贡献，今年的年度目标是。 1、今年上半年买房子。 2、落实结婚年制定的机会，将家庭会议组织开展起来。 3、每月送媳妇一朵花，15日送，以谢其辛苦照顾家庭。","permalink":"http://www.jacsons.com/2020/01/15/计划/2020年度计划/","photos":[]},{"tags":[{"name":"read","slug":"read","permalink":"http://www.jacsons.com/tags/read/"}],"title":"C语言的封装、继承、多态","date":"2019/10/28","text":"C语言的封装、继承、多态​ 封装、继承、多态是面向对象的三个基本特性，语言本身对这种特性具有要求与天然的支持。但是对于C语言这种面向过程的C语言来讲，却没有这种要求与限制。那么如何使用C语言来实现这是三种特性？以及能够给软件代码哪些好处呢？​ 本文将从来讲解封装、继承、多态基本概念，并且介绍使用C语言的样例，并且介绍利用这样的方式能够对软件特别是大型软件带来什么样的好处。 基本介绍封装基本概念 ​ 在面向对象编程中，封装（encapsulation）是将对象运行所需的资源封装在程序对象中——基本上，是方法和数据。对象是“公布其接口”。其他附加到这些接口上的对象不需要关心对象实现的方法即可使用这个对象。这个概念就是“不要告诉我你是怎么做的，只要做就可以了。”对象可以看作是一个自我包含的原子。对象接口包括了公共的方法和初始化数据。 C语言实现 object.h #ifndef OBJECT_H_INCLUDED#define OBJECT_H_INCLUDEDtypedef struct Object &#123; int (*publicOperator)(struct Object *obj, int p); int (*constructObject)(struct Object *obj); void (*freeObject)(struct Object *obj); void *privateData;&#125; Object_t;int objRegister(struct Object *obj);#endif // OBJECT_H_INCLUDED object.c #include \"Object.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct ObjectData &#123; int invokerCount;&#125; ObjectData_t;int publicOperator(Object_t *obj, int p)&#123; if (obj == NULL) &#123; return -1; &#125; ObjectData_t *objData = (ObjectData_t *)obj-&gt;privateData; printf(\"arg paramer : %d\\n\", p); printf(\"invoker time : %d\\n\", objData-&gt;invokerCount); objData-&gt;invokerCount++; return 0;&#125;int constructObject(Object_t *obj)&#123; ObjectData_t *objData = NULL; if (obj == NULL) &#123; return -1; &#125; objData = (ObjectData_t *)malloc(sizeof(ObjectData_t)); if (objData == NULL) &#123; return -1; &#125; objData = memset(objData, 0, sizeof(ObjectData_t)); if (objData == NULL) &#123; free(objData); return -1; &#125; objData-&gt;invokerCount = 0; obj-&gt;privateData = (void *)objData; return 0;&#125;void freeObject(Object_t *obj)&#123; if (obj != NULL &amp;&amp; obj-&gt;privateData != NULL) &#123; free(obj-&gt;privateData); &#125;&#125;int objRegister(Object_t *obj)&#123; obj-&gt;publicOperator = publicOperator; obj-&gt;constructObject = constructObject; obj-&gt;freeObject = freeObject; return 0;&#125; main.c #include \"Object.h\"int main()&#123; Object_t object; objRegister(&amp;object); object.constructObject(&amp;object); object.publicOperator(&amp;object, 1); object.publicOperator(&amp;object, 1); object.publicOperator(&amp;object, 1); object.freeObject(&amp;object); return 0;&#125; 运行结果： arg paramer : 1 invoker time : 0 arg paramer : 1 invoker time : 2 arg paramer : 1 invoker time : 3 小结 以上就是对利用C语言实现封装的过程，其中有两个需要注意，暴露出来的只是一些函数的实现，其中的数据是以void *private提供出来，这样正是封装的核心思想。看似一点小技巧，其实能够带来避免在大型程序中变量多出调用，导致项目在功能需要小型变更时，却带来无法查询与修改的问题。 继承基本概念 ​ 如果一个类别A“继承自”另一个类别B，就把这个A称为“B的子类别”，而把B称为“A的父类别”也可以称“B是A的超类”。继承可以使得子类别具有父类别的各种属性和方法，而不需要再次编写相同的代码。在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。另外，为子类别追加新的属性和方法也是常见的做法。 C语言实现​ 在上面介绍的封装的用例基础上，编写继承的用例。先编码介绍 如下： object.h #ifndef OBJECT_H_INCLUDED#define OBJECT_H_INCLUDEDtypedef struct Object &#123; int (*publicOperator)(struct Object *obj, int p); int (*constructObject)(struct Object *obj); void (*freeObject)(struct Object *obj); void *privateData;&#125; Object_t;int objRegister(struct Object *obj);#endif // OBJECT_H_INCLUDED object.c #include \"Object.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct ObjectData &#123; int invokerCount;&#125; ObjectData_t;static int publicOperator(Object_t *obj, int p)&#123; if (obj == NULL) &#123; return -1; &#125; ObjectData_t *objData = (ObjectData_t *)obj-&gt;privateData; printf(\"parent arg paramer : %d\\n\", p); printf(\"parent invoker time : %d\\n\", objData-&gt;invokerCount); objData-&gt;invokerCount++; return 0;&#125;static int constructObject(Object_t *obj)&#123; ObjectData_t *objData = NULL; if (obj == NULL) &#123; return -1; &#125; objData = (ObjectData_t *)malloc(sizeof(ObjectData_t)); if (objData == NULL) &#123; return -1; &#125; objData = memset(objData, 0, sizeof(ObjectData_t)); if (objData == NULL) &#123; free(objData); return -1; &#125; objData-&gt;invokerCount = 0; obj-&gt;privateData = (void *)objData; return 0;&#125;static void freeObject(Object_t *obj)&#123; if (obj != NULL &amp;&amp; obj-&gt;privateData != NULL) &#123; free(obj-&gt;privateData); &#125;&#125;int objRegister(Object_t *obj)&#123; obj-&gt;publicOperator = publicOperator; obj-&gt;constructObject = constructObject; obj-&gt;freeObject = freeObject; return 0;&#125; ChildObject.h #ifndef CHILDOBJECT_H_INCLUDED#define CHILDOBJECT_H_INCLUDED#include \"Object.h\"typedef struct ChildObject &#123; Object_t parentObj; int (*publicOperator)(struct ChildObject *obj, int p); int (*constructObject)(struct ChildObject *obj); void (*freeObject)(struct ChildObject *obj); void *privateData;&#125; ChildObject_t;int childRegister(ChildObject_t *obj);#endif // CHILDOBJECT_H_INCLUDED ChildObject.c #include \"ChildObject.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;typedef struct ChildObjectData &#123; int invokerCount;&#125; ChildObjectData_t;static int publicOperator(ChildObject_t *obj, int p)&#123; if (obj == NULL) &#123; return -1; &#125; ChildObjectData_t *objData = (ChildObjectData_t *)obj-&gt;privateData; printf(\"child arg paramer : %d\\n\", p); printf(\"child invoker time : %d\\n\", objData-&gt;invokerCount); objData-&gt;invokerCount++; obj-&gt;parentObj.publicOperator(&amp;obj-&gt;parentObj, 1); return 0;&#125;static int constructObject(ChildObject_t *obj)&#123; int ret; ChildObjectData_t *objData = NULL; if (obj == NULL) &#123; return -1; &#125; ret = obj-&gt;parentObj.constructObject(&amp;obj-&gt;parentObj); if (ret != 0) &#123; return -1; &#125; objData = (ChildObjectData_t *)malloc(sizeof(ChildObjectData_t)); if (objData == NULL) &#123; return -1; &#125; objData = memset(objData, 0, sizeof(ChildObjectData_t)); if (objData == NULL) &#123; free(objData); return -1; &#125; objData-&gt;invokerCount = 0; obj-&gt;privateData = (void *)objData; return 0;&#125;static void freeObject(ChildObject_t *obj)&#123; if (obj != NULL &amp;&amp; obj-&gt;privateData != NULL) &#123; free(obj-&gt;privateData); &#125; obj-&gt;parentObj.freeObject(&amp;obj-&gt;parentObj);&#125;int childRegister(ChildObject_t *obj)&#123; objRegister(&amp;obj-&gt;parentObj); obj-&gt;publicOperator = publicOperator; obj-&gt;constructObject = constructObject; obj-&gt;freeObject = freeObject; return 0;&#125; main #include \"ChildObject.h\"int main()&#123; ChildObject_t object; childRegister(&amp;object); object.constructObject(&amp;object); object.publicOperator(&amp;object, 1); object.publicOperator(&amp;object, 1); object.publicOperator(&amp;object, 1); object.freeObject(&amp;object); return 0;&#125; 运行结果： child arg paramer : 1child invoker time : 0parent arg paramer : 1parent invoker time : 0child arg paramer : 1child invoker time : 1parent arg paramer : 1parent invoker time : 1child arg paramer : 1child invoker time : 2parent arg paramer : 1parent invoker time : 2 小结​ 该部分的介绍即为继承的介绍，对于C语言，并没有语法上来支持继承机制，但是可以通过模拟面向对象的方式来实现继承，此种的关键是在子类中声明父类变量或者指针变量。 多态 基本概念 在面向对象语言中，接口的多种不同的实现方式即为多态。引用Charlie Calverts对多态的描述——多态性是允许你将父对象设置成为一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 C语言实现 ObjectModel.h#ifndef OBJECTMODEL_H_INCLUDED#define OBJECTMODEL_H_INCLUDEDtypedef struct ObjectModel &#123; int (*publicOperator)(struct ObjectModel *obj, int p);&#125; ObjectModel_t;#endif // OBJECTMODEL_H_INCLUDED Object.h #ifndef OBJECT_H_INCLUDED#define OBJECT_H_INCLUDED#include \"ObjectModel.h\"int objRegister1(ObjectModel_t *obj);#endif // OBJECT_H_INCLUDED Object.c #include \"Object.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;static int publicOperator(ObjectModel_t *obj, int p)&#123; if (obj == NULL) &#123; return -1; &#125; printf(\"type 1 arg paramer : %d\\n\", p); printf(\"type 1 invoker\\n\"); return 0;&#125;int objRegister1(ObjectModel_t *obj)&#123; obj-&gt;publicOperator = publicOperator; return 0;&#125; Object2.h #ifndef CHILDOBJECT_H_INCLUDED#define CHILDOBJECT_H_INCLUDED#include \"ObjectModel.h\"int objRegister2(ObjectModel_t *obj);#endif // CHILDOBJECT_H_INCLUDED Object2.c #include \"ChildObject.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;static int publicOperator(ObjectModel_t *obj, int p)&#123; printf(\"type 2 arg paramer : %d\\n\", p); printf(\"type 2 invoker\\n\"); return 0;&#125;int objRegister2(ObjectModel_t *obj)&#123; obj-&gt;publicOperator = publicOperator; return 0;&#125; main #include \"ObjectModel.h\"#include \"Object.h\"#include \"Object2.h\"int main()&#123; ObjectModel_t object; objRegister1(&amp;object); object.publicOperator(&amp;object, 1); objRegister2(&amp;object); object.publicOperator(&amp;object, 1); return 0;&#125; 运行结果：type 1 arg paramer : 1type 1 invokertype 2 arg paramer : 1type 2 invoker小结 ​ 以上例子是一个简单的例子来实现多态。多态主要是对函数来说，通过函数指针，在不同的注册，相同的调用结果却不同。 总结​ 至此，本文对封装、继承、多态的简单介绍完成。虽然概念看的简单，但是在实际的应用中，通过结合设计模式，将能够设计中高内聚低耦合的软件，适应与解决软件中功能经常变更的问题。即使不去了解设计模式，应用这三种知识能够保证代码基本质量，不会难以维护的问题。","permalink":"http://www.jacsons.com/2019/10/28/阅读/Cdesign/ObjectInheritMuti/","photos":[]},{"tags":[{"name":"read","slug":"read","permalink":"http://www.jacsons.com/tags/read/"}],"title":"建筑者模式","date":"2019/10/21","text":"建筑者模式​ 建筑模式与上面工厂模式一样，都是从new出对象的角度来设计，但是与工厂模式不同的是：工厂关注的是一类（簇），而建筑模式关注的是组成的细节。 类图 C语言实现优点、适应范围小结","permalink":"http://www.jacsons.com/2019/10/21/阅读/Cdesign/buildingPattern/","photos":[]},{"tags":[{"name":"read","slug":"read","permalink":"http://www.jacsons.com/tags/read/"}],"title":"抽象工厂","date":"2019/10/07","text":"抽象工厂​ 简单工厂类似于单一工厂，生产的产品为同一类型的产品，抽象工厂更加类似于组装厂。例如电脑，其中有内存和cpu。cpu可以有多重型号（一个简单工厂生成），内存也有多种型号（另一个简单工厂）。 类图 优点、适应范围​ 抽象工厂相当于多个简单工厂的组合。具有组合的易扩展的优点，当增加某种类型时，如shape增加hexshape时；或者新增加种类型时，如现在加material时，只需要在AbstractFactor中新增加一个函数。如上的增加不会给系统的整个架构代码冲击。 C语言实现具体实现参照类图查看他们之间的关系。 产品类 color及其实现 color.h #ifndef __COLOR_H__#define __COLOR_H__typedef enum ColorEnum &#123; GREY, YELLOW, DEFAULT&#125; ColorEnum_t;typedef struct Color &#123; void (*operators)(); void *child;&#125; Color_t;typedef struct GreyColor &#123; Color_t color;&#125; GreyColor_t;typedef struct YellowColor &#123; Color_t color;&#125; YellowColor_t;typedef struct DefaultColor &#123; Color_t color;&#125; DefaultColor_t;void* constructGreyColor();void freeGreyColor(void *ptr);void* constructYellowColor();void freeYellowColor(void *ptr);void* constructDefaultColor();void freeDefaultColor(void *ptr);#endif color.c #include \"color.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void greyOperator()&#123; printf(\"my name is grey\\n\");&#125;void yellowOperator()&#123; printf(\"my name is yellow\\n\");&#125;void defaultColorOperator()&#123; printf(\"don't support this type\\n\");&#125;void* constructGreyColor()&#123; GreyColor_t *grepColor = NULL; grepColor = (GreyColor_t *)malloc(sizeof(GreyColor_t)); grepColor-&gt;color.operators = greyOperator; grepColor-&gt;color.child = grepColor; return grepColor;&#125;void freeGreyColor(void *ptr)&#123; if (ptr != NULL) &#123; free(ptr); &#125;&#125;void* constructYellowColor()&#123; YellowColor_t *yellowColor = NULL; yellowColor = (YellowColor_t *)malloc(sizeof(YellowColor_t)); yellowColor-&gt;color.operators = yellowOperator; yellowColor-&gt;color.child = yellowColor; return yellowColor;&#125;void freeYellowColor(void *ptr)&#123; if (ptr != NULL) &#123; free(ptr); &#125;&#125;void* constructDefaultColor()&#123; DefaultColor_t *defaultColor = NULL; defaultColor = (DefaultColor_t *)malloc(sizeof(DefaultColor_t)); defaultColor-&gt;color.operators = defaultColorOperator; defaultColor-&gt;color.child = defaultColor; return defaultColor;&#125;void freeDefaultColor(void *ptr)&#123; if (ptr != NULL) &#123; free(ptr); &#125;&#125; shape及其实现 shape.h #ifndef __SHAPE_H__#define __SHAPE_H__typedef enum ShapeEnum &#123; RETANGLE_SHAPE, CIRCLE_SHAPE, DEFAULT_SHAPE&#125; ShapeEnum_t;typedef struct Shape &#123; void(*operators)(); void *child;&#125; Shape_t;// three relize shape classtypedef struct RetangleShape &#123; Shape_t shape;&#125; RetangleShape_t;typedef struct CircleShape &#123; Shape_t shape;&#125; CircleShape_t;typedef struct DefaultShape &#123; Shape_t shape;&#125; DefaultShape_t;void* constructRetangleShape();void freeRetangleShape(void *ptr);void* constructCircleShape();void freeCircleShape(void *ptr);void* constructDefaultShape();void freeDefaultShape(void *ptr);#endif shape.c #include \"shape.h\"#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;void retangleOperator()&#123; printf(\"my name is retangle\\n\");&#125;void circleOperator()&#123; printf(\"my name is circle\\n\");&#125;void defaultShapeOperator()&#123; printf(\"don't support this type shape\\n\");&#125;void* constructRetangleShape()&#123; RetangleShape_t *retangleShape = NULL; retangleShape = (RetangleShape_t *)malloc(sizeof(RetangleShape_t)); retangleShape-&gt;shape.operators = retangleOperator; retangleShape-&gt;shape.child = retangleShape; return retangleShape;&#125;void freeRetangleShape(void *ptr)&#123; if (ptr != NULL) &#123; free(ptr); &#125;&#125;void* constructCircleShape()&#123; CircleShape_t *circleShape = NULL; circleShape = (CircleShape_t *)malloc(sizeof(CircleShape_t)); circleShape-&gt;shape.operators = circleOperator; circleShape-&gt;shape.child = circleShape; return circleShape;&#125;void freeCircleShape(void *ptr)&#123; if (ptr != NULL) &#123; free(ptr); &#125;&#125;void* constructDefaultShape()&#123; DefaultShape_t *defaultShape = NULL; defaultShape = (DefaultShape_t *)malloc(sizeof(DefaultShape_t)); defaultShape-&gt;shape.operators = defaultShapeOperator; defaultShape-&gt;shape.child = defaultShape; return defaultShape;&#125;void freeDefaultShape(void *ptr)&#123; if (ptr != NULL) &#123; free(ptr); &#125;&#125; 生产类 colorFactory.h #ifndef __COLOR_FACTORY_H__#define __COLOR_FACTORY_H__#include \"color.h\"typedef struct ColorFactory &#123; Color_t *(*createColor)(ColorEnum_t colorEnum); void (*colorFree)(void *ptr);&#125; ColorFactory_t;ColorFactory_t *GetColorInstance();#endif colorFactory.c #include \"colorFactory.h\"#include &lt;stdlib.h&gt;static Color_t* createColor(ColorEnum_t colorEnum)&#123; switch (colorEnum) &#123; case GREY: &#123; GreyColor_t *greyColor = NULL; greyColor = (GreyColor_t*)constructGreyColor(); return &amp;greyColor-&gt;color; &#125;; case YELLOW: &#123; YellowColor_t *yellowColor = NULL; yellowColor = (YellowColor_t*)constructYellowColor(); return &amp;yellowColor-&gt;color; &#125; default: &#123; DefaultColor_t *defaultColor = NULL; defaultColor = (DefaultColor_t*)constructDefaultColor(); return &amp;defaultColor-&gt;color; &#125; &#125;&#125;static void colorFree(void *ptr)&#123; if(ptr != NULL &amp;&amp; ((Color_t*)ptr)-&gt;child != NULL) &#123; free(((Color_t*)ptr)-&gt;child); &#125;&#125;ColorFactory_t *GetColorInstance()&#123; static ColorFactory_t colorFactor = &#123; .createColor = createColor, .colorFree = colorFree &#125;; return &amp;colorFactor;&#125; shapeFactory.h #ifndef __SHAPE_FACTORY_H__#define __SHAPE_FACTORY_H__#include \"shape.h\"typedef struct ShapeFactory &#123; Shape_t *(*createShape)(ShapeEnum_t shapeEnum); void (*shapeFree)(void *ptr);&#125; ShapeFactory_t;ShapeFactory_t *GetShapeInstance();#endif shapeFactory.c #include \"shapeFactory.h\"#include &lt;stdlib.h&gt;static Shape_t* createShape(ShapeEnum_t shapeEnum)&#123; switch (shapeEnum) &#123; case RETANGLE_SHAPE: &#123; RetangleShape_t *retangleShape= NULL; retangleShape = (RetangleShape_t*)constructRetangleShape(); return &amp;retangleShape-&gt;shape; &#125; case CIRCLE_SHAPE: &#123; CircleShape_t *circleShape = NULL; circleShape = (CircleShape_t*)constructCircleShape(); return &amp;circleShape-&gt;shape; &#125; default: &#123; DefaultShape_t *defaultShape = NULL; defaultShape = (DefaultShape_t*)constructDefaultShape(); return &amp;defaultShape-&gt;shape; &#125; &#125;&#125;static void shapeFree(void *ptr)&#123; if(ptr != NULL &amp;&amp; ((Shape_t*)ptr)-&gt;child != NULL) &#123; free(((Shape_t*)ptr)-&gt;child); &#125;&#125;ShapeFactory_t *GetShapeInstance()&#123; static ShapeFactory_t shapeFactor = &#123; .createShape = createShape, .shapeFree = shapeFree &#125;; return &amp;shapeFactor;&#125; 集成个生产类组成抽象工厂 abstractFactory.h #ifndef __ABSTRACT_FACTORY_H__#define __ABSTRACT_FACTORY_H__#include \"colorFactory.h\"#include \"shapeFactory.h\"typedef enum type &#123; COLOR, SHAPE&#125; type_t;typedef struct AbstractFactory &#123; Color_t* (*colorGenerate)(ColorEnum_t colorEnum); void (*freeColor)(void *ptr); Shape_t* (*shapeGenerate)(ShapeEnum_t shapeEnum); void (*freeShape)(void *ptr); void* (*generate)(type_t productType, int type); void (*freeProduct)(type_t productType, void *ptr);&#125; AbstractFactory_t;AbstractFactory_t *GetInstance();#endif abstractFactory.c #include &lt;stdio.h&gt;#include \"abstractFactory.h\"static Color_t* colorGenerate(ColorEnum_t colorEnum)&#123; return GetColorInstance()-&gt;createColor(colorEnum);&#125;static void freeColor(void *ptr)&#123; return GetColorInstance()-&gt;colorFree(ptr);&#125;static Shape_t* shapeGenerate(ShapeEnum_t shapeEnum)&#123; return GetShapeInstance()-&gt;createShape(shapeEnum);&#125;static void freeShape(void *ptr)&#123; return GetShapeInstance()-&gt;shapeFree(ptr);&#125;static void* generate(type_t productType, int type)&#123; switch (productType) &#123; case COLOR: return colorGenerate((ColorEnum_t)type); case SHAPE: return shapeGenerate((ShapeEnum_t)type); default: return NULL; &#125;&#125;static void freeProduct(type_t productType, void *ptr)&#123; switch (productType) &#123; case COLOR: return freeColor(ptr); case SHAPE: return freeShape(ptr); default: return; &#125;&#125;AbstractFactory_t *GetInstance()&#123; static AbstractFactory_t abstracFactory = &#123; .colorGenerate = colorGenerate, .freeColor = freeColor, .shapeGenerate = shapeGenerate, .freeShape = freeShape, .generate = generate, .freeProduct = freeProduct, &#125;; return &amp;abstracFactory;&#125; 测试 测试代码 main.c #include &lt;stdio.h&gt;#include \"abstractFactory.h\"int main()&#123; Color_t *color= (Color_t*)GetInstance()-&gt;generate(COLOR, GREY); color-&gt;operators(); GetInstance()-&gt;freeProduct(COLOR, color); color= (Color_t*)GetInstance()-&gt;generate(COLOR, YELLOW); color-&gt;operators(); GetInstance()-&gt;freeProduct(COLOR, color); Shape_t *shape = (Shape_t*)GetInstance()-&gt;generate(SHAPE, RETANGLE_SHAPE); shape-&gt;operators(); GetInstance()-&gt;freeProduct(SHAPE, shape); return 0;&#125; module.mk SOURCE = $(wildcard *.c)OBJS = $(patsubst %.c, %.o, $(SOURCE))all:abstractabstract: $(OBJS) gcc -o $@ $^%.o : %c gcc -o $@ $&lt;.PHONY:cleanclean: rm *.o abstract 编译运行 执行make. /abstract 运行结果 my name is greymy name is yellowmy name is retangle 小结 ​ 以上就是抽象工厂模式，从中可以体会到，抽象工厂是整体和部分的类关系的扩展，更偏向于部分架构设计。因此特别适合于那种整体与局部关系的特性中，适应功能（工具）多样化的需求。","permalink":"http://www.jacsons.com/2019/10/07/阅读/Cdesign/AbstractorFactory/","photos":[]},{"tags":[{"name":"read","slug":"read","permalink":"http://www.jacsons.com/tags/read/"}],"title":"简单工厂","date":"2019/09/21","text":"简单工厂​ 简单工厂是根据使用统一的接口，在保证主流程结构不变的情况下，根据传入的参数来改变获取不同的执行行数从而获取不同的结果。简单工厂体现的变（工具）与不变（主流程）分离的思想。在主流程不用动的情况下，便于工具的修改与扩充。 C语言实现 simpleFactor.h #ifndef __SIMPLE_FACTORY_H__#define __SIMPLE_FACTORY_H__typedef enum type &#123; CIRCLE = 0, REGTANCLE, OTHERS&#125; type_t;typedef struct object &#123; int (*operators)(const struct object *that);&#125; object_t;object_t *Object_Factory(type_t type);#endif simpleFactor.c #include &lt;stdio.h&gt;#include \"simpleFactory.h\"int default_operator(const struct object *that)&#123; printf(\"oh no, this type not support\\n\");&#125;int circle_operator(const struct object *that)&#123; printf(\"hello, my name is circle\\n\");&#125;int retangle_operator(const struct object *that)&#123; printf(\"hello, my name is retangle\\n\");&#125;object_t *Object_Factory(type_t type)&#123; static object_t g_object = &#123; 0 &#125;; switch (type) &#123; case CIRCLE : g_object.operators = circle_operator; break; case REGTANCLE : g_object.operators = retangle_operator; break; default: g_object.operators = default_operator; &#125; return &amp;g_object;&#125; main.c #include &lt;stdio.h&gt;#include \"simpleFactory.h\"int main()&#123; object_t *objectp = Object_Factory(CIRCLE); objectp-&gt;operators(objectp); objectp = Object_Factory(REGTANCLE); objectp-&gt;operators(objectp); objectp = Object_Factory(OTHERS); objectp-&gt;operators(objectp); return 0;&#125; 运行结果编译 gcc main.c simpleFactory.c -o simpleFactory 运行结果 hello, my name is circlehello, my name is retangleoh no, this type not support 小结​ 简单工厂模式其实就是工具集能够根据传入的参数获取不同的对象，从而实现主流程的多态。该模式幻化到架构层集其实最好的实现是将结构分为多个层级，每个层级的交互过程不应当让调用层考虑被调用方过多的细节。只需要传递不同的参数，来影响调用方的运行结果，即高内聚低耦合。","permalink":"http://www.jacsons.com/2019/09/21/阅读/Cdesign/simpleFactory/","photos":[]},{"tags":[{"name":"read","slug":"read","permalink":"http://www.jacsons.com/tags/read/"}],"title":"单例模式","date":"2019/09/19","text":"单例模式​ 单例模式应该是最简单的模式了，但是使用面是非常非常的广泛的。如：各种工具集，驱动中对应的每种设备接口集其实也应该设计为单例模式。 C语言实现 singleInstance.h #ifndef __SINGLE_INSTANCE_H__#define __SINGLE_INSTANCE_H__#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;typedef struct object &#123; void *private; int (*operators)(const struct object *that);&#125; object_t;object_t *GET_INSTANCE(); #endif singleInstance.c #include &lt;stdio.h&gt;#include \"singleInstance.h\"static int operators(const struct object *that)&#123; printf(\"Hello world single instacne\\n\");&#125;object_t *GET_INSTANCE()&#123; static object_t g_object = &#123; 0 &#125;; if (g_object.operators == NULL) &#123; g_object.operators = operators; &#125; return &amp;g_object;&#125; main.h #include &lt;stdio.h&gt;#include \"singleInstance.h\"int main()&#123; object_t *object = GET_INSTANCE(); if (object == NULL) &#123; printf(\"object is null! \\n\"); return -1; &#125; object-&gt;operators(object); object-&gt;operators(object); return 0;&#125; 运行结果执行gcc命令 gcc main.c singleInstance.c -o singleInstance运行结果： Hello world single instacne, private date = 1! Hello world single instacne, private date = 1!","permalink":"http://www.jacsons.com/2019/09/19/阅读/Cdesign/SingleInstance/","photos":[]},{"tags":[{"name":"read","slug":"read","permalink":"http://www.jacsons.com/tags/read/"}],"title":"设计模式","date":"2019/09/19","text":"设计模式​ 距离上一次阅读设计模式已经具体很多年了，经过几年从事java的工作，懵懵懂懂感觉到各种架构的巧妙，也体会到了其中蕴含的各种设计模式以及其带来的种种好处。如今转行从事C语言开发，虽然印象中传统的C语言程序都是规模很小的程序，使用不到各种设计模式，从百度到的C语言版本的设计模式结果就可以看到，更别说成熟架构。但如今，C语言的程序已经规模不断在增大，不再试几千行代码规模。现已经发展到万，十万级的代码规模了，如不引入设计模式，后期的功能的修改与维护将会疲惫不堪。故又重拿起设计模式，重新使用C语言来实现。 设计模式的汇总 C的封装、继承、多态 封装、继承、多态是面向对象的三个基本特性，语言本身对这种特性具有要求与天然的支持。但是对于C语言这种面向过程的C语言来讲，却没有这种要求与限制。那么如何使用C语言来实现这是三种特性？以及能够给软件代码哪些好处呢？ 单例模式 单例模式应该是最简单的模式了，单是使用面是非常非常的广泛的。如：各种工具集，驱动中对应的每种设备接口集其实也应该设计为单例模式。 简单工厂 简单工厂是根据使用统一的接口，在保证主流程结构不变的情况下，根据传入的参数来改变获取不同的执行行数从而获取不同的结果。 抽象工厂简单工厂类似于单一工厂，生产的产品为同一类型的产品，抽象工厂更加类似于组装厂。例如电脑，其中有内存和cpu。cpu可以有多重型号（一个简单工厂生成），内存也有多种型号（另一个简单工厂），具体内容见抽象工厂章节。 建筑模式 建筑模式与上面工厂模式一样，都是从new出对象的角度来设计，但是与工厂模式不同的是：工厂关注的是一类（簇），而建筑模式关注的是部件的组成。","permalink":"http://www.jacsons.com/2019/09/19/阅读/Cdesign/introduction/","photos":[]},{"tags":[{"name":"plan","slug":"plan","permalink":"http://www.jacsons.com/tags/plan/"}],"title":"十年规划","date":"2019/08/29","text":"十年规划 今天迎来了30岁的生日，俗话说三十而立。虽然性格、成熟度离这个还很远，但是总算在今年找到了人生事业奋斗的方向。 30岁，同时也庆幸有一个这么好的家庭: 爱我的老婆，一直以来无时无刻都照顾着我的妈妈，还有那在媳妇胎中的孩子。特别感谢今天妈妈做的好吃的，以及媳妇定的蛋糕，还有爸爸、哥哥、老丈人、姑姑送来的祝福。让我今天这餐饭吃的真的很开心。 30岁，已过半甲，无论过去的辉煌与低谷、开心与不开心都已经过去。很庆幸在此刻仍然没有忘记自己的初衷：找到喜欢的方向，并持续努力成为专家、CTO、并希望以后拥有自己的一家公司。 在此，也给自己接下来的十年制定自己的规划：1、2年内成为mde。2、5年内成为SE。3、10年内成为一个百人项目的CTO。这也是我今天许下的三个愿望。同时对老婆说，30岁男人，说出的话一定要算数。 文末，上传一张今天的照片，以此纪念此时的自己，也为自己的未来加油！","permalink":"http://www.jacsons.com/2019/08/29/计划/十年规划/","photos":[]},{"tags":[{"name":"thinking","slug":"thinking","permalink":"http://www.jacsons.com/tags/thinking/"}],"title":"关于软件质量总结与思考","date":"2019/08/26","text":"背景​ 这段时间项目进入了迭代的尾期，主要开始处理软件质量的问题，从codestyle修改到静态检查的清理、再到安全代码检视，以及后面还有得cmetric等等。 本文是对这一阶段的工作过程中发现的codestyle、安全代码检视等各种问题做总结，另外也对项目中存在的问题做一点点思考。 常见codestyle问题​ codestyle主要是违反公司的编码规范的问题，本节是对违反的公司编码规范的典型问题的总结。 主要的问题有1、四空格对齐问题2、if等单条件语句未加大括号3、宏定义的多行代码未加do{…}while(0)4、宏定义的参数在使用过程中未添加括号。5、魔鬼数字6、函数超过50行7、全局变量命名未添加g8、变量使用不必要的初始化。 常见安全编码问题​ 安全编码是根据公司的安全编码规范项对代码进行排查，本节是介绍常见违反公司安全编码规范的问题进行总结 主要的问题有 1、日志问题 错误状态下未打印日志 打印日志中未打印返回值 多条件打印下，日志打印不完全。 2、数据类型使用混乱，如长度使用int(应该使用size_t). 特别注意进行位运算一定要使用无符号类型。 3、资源申请未按照要求赋初值，资源释放未赋默认值。 4、结构体类型申请未赋默认值， malloc申请内存后未使用memset_s清零. 5、函数参数在函数体类未改变，未使用const类型。 6、传入的参数为数组或字符串（const字符串除外），未传入长度。 7、对于ioctl的结果，未进行校验直接使用。 8、数据进行运算时，不考虑溢出问题。 9、if语句条件判断不完全。 10、返回值类型不统一。 安全考试中常见的问题1、赋值给memset，malloc、等传递的为负数或者运算后溢出的数值。 2、memset 可能导致命令注入。 3、sccanf 返回值一定要判断个数。 4、存储密码类型的变量，使用完后要清零。 常见的代码问题​ 在检视过程中发现项目中存在几个问题： 项目中常见问题 1、代码中基本功能每个模块都写一份。 2、同一个文件中重复代码特别严重，基本没有考虑共同点做简化。 3、没有C++封装、低耦合高内聚思想，有些员工具有C++基本思想，但是代码写出来后将数据直接暴露出去，导致各种多线程问题频繁发出。 4、重点模块新员工写，以上几点问题代码中层出不穷，解决问题疲于奔命，直接导致项目质量持续恶化。 以上问题的几点解决办法思考 1、分析项目常用功能，编写公共组件模块，由有经验的一部分员工编写及维护。 2、赋能设计模式，提升员工低耦合高内聚思想。 3、区分项目中重点模块、复杂模块、普通模块、简单模块，由有经验的人员编写重点、复杂模块，至少完成这些模块的框架结构，新员工、新人完成普通模块与简单模块。重点、复杂模块有一老员工进行架构看护。","permalink":"http://www.jacsons.com/2019/08/26/总结/思考/关于软件质量的思考/","photos":[]},{"tags":[{"name":"conclusion","slug":"conclusion","permalink":"http://www.jacsons.com/tags/conclusion/"}],"title":"科目二考试失败总结","date":"2019/07/23","text":"科目二考试失败总结 昨天与今天备考与参加科目二考试，辛苦两天，结果科目二考试直接两把都挂在倒车入库左转弯。在平时模拟练习的过程中，一直很稳定，从未出现过倒库失败的情况。直接原因分析为一下两个方面：一、离合没有踩稳，导致车速过快压线。二、左转弯过程中，不需要打死的位置，直接打死导致左侧过窄导致左侧压线。 出现以上两个根本的原因是心态有些慌张，导致在考试过程中，第一个项目直接挂掉。 再进一步分析，根据考科目一的过程，在前几个问题考题连续出错，到10多道题目时才稳定下来。据此可以了解到这是本来的性格问题。性格问题没有办法解决，那么只有通过加强平时的训练来解决该问题。但是今天上午在加强练库的时候其他三人多次联系了倒库，而自己只联系了倒右库。 根据进一步分析得出结论，无论自己多么娴熟，在容易紧张的项目一定要在进行前，加强、加强再加强联系，千万不要掉以轻心。 再将该问题上升到生活之中，可以发现存在以下几个问题：一、懦落，不争取自己的利益（练车只倒右库）。二、办事情无逻辑。（考试进行倒库前，未理清楚路线，以及特别是中间出现的各种状况的未提前分析）。三、胆小。（考试过程中的慌张）。四、处事情太随意，未有处理事情原则(练车过程中，未对自己的方法做出总结归纳，导致联系混乱)。 针对以上问题，个人的思路：一、处事前缕清思路，考虑各种异常情况。二、平时不要蒙头做事，要大胆抬头处事。三、自己的利益一定要去争取。","permalink":"http://www.jacsons.com/2019/07/23/总结/生活/科目二考试失败总结/","photos":[]},{"tags":[{"name":"linux","slug":"linux","permalink":"http://www.jacsons.com/tags/linux/"}],"title":"Linux系统中的互斥量","date":"2019/07/21","text":"Linux系统中的互斥量linux系统中所有互斥量都依赖于汇编的两个指定ldrex指定和strex指定，这两个指定都是原子指定。依赖着两个指定组成了汇编系统的并发系统的函数。 对于系统两说出现竞争的情况是：1、同一CPU内的抢占导致的竞争（抢占式系统出现）2、CPU与CPU之间的竞争。 自旋锁自旋转锁的特点是自旋转，是完全占用cpu的（只有中断才会让出本CPU）。 基本自旋锁 spin_lock &amp; spin_unlock （中断中只能使用基本的spin_lock) 关中断自旋锁： 自旋期间关闭中断，只关闭本cpu的中断 spin_lock_irq = spin_lock + local_irq_disable spin_unlock_irq = spin_lock + local_irq_enbale 保存中断状态自旋锁 : 自旋期间关闭中断并记录中断状态，即CPSR的信息 spin_lock_irqsave = spin_lock + local_irq_save spin_unlock_irqrestore = spin_lock + local_irq_restore 关下半部分中断自旋锁 ： 目前作用不明 spin_lock_bh = spin_lock + local_bh_diable spin_unlock_bh = spin_lock + local_bh_enable 尝试锁 spin_trylock &amp; spin_tryunlock 典型使用CPU1：spin_lock_irqsave -&gt; spin_unlock_irqrestore CPU2: spin_lock_irqsave -&gt; spin_unlock_irqrestore 中断： spin_lock -&gt; spin_unlock 读写自旋锁写同时只能是一个，读可以并发。 读写之间是互斥的。 读 read_trylock read_lock read_lock_irq read_lock_irqsave read_lock_bh 写 write_trylock write_lock write_lock_irq write_lock_irqsave write_lock_bh 顺序锁写同时只能是一个，读可以并发。 读写之间是不互斥。 读 read_seqtrylock read_seqlock read_seqlock_irq read_seqlock_irqsave read_seqlock_bh 写 write_seqtrylock write_seqlock write_seqlock_irq write_seqlock_irqsave write_seqlock_bh 读-复制-更新RCU的有点在于可以同时存在多个读与多个写操作，但是因写操作开销大，当多个写操作过多时，会存在性能下降。建议10%左右的写，90%的读使用该类型锁。RCU 不会进行互斥，是通过new新的对象，然后替换，再删除老对象的方式对内容进行保护。老队形不会立马删除，而是一种类似于java种的内存机制， RCU变量需要注册于释放，在linux系统进程切换的过程中会判断所有线程对该RCU变量的引用为0，才会调用回调函数进行内存的释放。 rcu_read_lock rcu_read_unlock synchronize_rcu 信号量信号量可以0、1、n 类似java中的信号量 函数 down down_interruptible : 进程能够允许被信号打断 down_try_lock up 互斥体互斥体与自旋锁区别是，互斥体能够让出进程进行等待，因该特性不能够在中断中使用该特性。 函数 mutex_lock mutex_lock_interruptible mutex_try_lock 使用过程1、 mutex_init2、 mutex_lock3、 mutex_unlock4、 mutex_release 完成量用于一个执行单元等待另一执行单元完成某事。 函数wait_for_completion唤醒completecomplete_all 使用方式1、init_completion 或reinit_completion2、wait_for_completion3、complete 或 complete_all 总结自旋锁用于小临界去、互斥量用于大临界去（因可能让CPU休眠），其他待深入使用后补充。","permalink":"http://www.jacsons.com/2019/07/21/阅读/linux/linux互斥量/","photos":[]},{"tags":[{"name":"linux","slug":"linux","permalink":"http://www.jacsons.com/tags/linux/"}],"title":"makefile学习总结","date":"2019/07/15","text":"Makefile学习总结变量变量定义 变量定义变量分为立即变量（:=)和延迟变量 变量使用: $() 注意事项1、延迟变量展开运行时分析，编译时展开。2、一般在目标、目标依赖中使用立即展开变量。3、在名利中一般使用延迟变量目标变量1、一般变量2、目标变量3、","permalink":"http://www.jacsons.com/2019/07/15/阅读/linux/makefile/","photos":[]},{"tags":[{"name":"project","slug":"project","permalink":"http://www.jacsons.com/tags/project/"}],"title":"常见静态检查问题","date":"2019/07/15","text":"背景目前从事底层软件工作一年多以来，项目组的静态检查（pclint、codemars、fortiy、codestyle）属于我工作的一部分，也一直观察项目组在这一块的告警数据。现对齐进行统计与汇总，这些都很基础，但是常常容易犯错，也谨记以提醒自己。 常见静态检查问题本文介绍项目过程中常遇到的静态检查问题： fority &amp; coverity问题1、指针未赋值2、多余的赋值。3、指针加上运算未对时出现截断现象（原因是int * int 必须为long ，故因为int * long）4、指针不使用时，需要赋值为NULL5、文件打开时如果使用create命令，需要制定create后文件的访问权限设置。6、外部输入的文件路径，需要realpath7、宏定位中，输入的每一个参数都需要使用括号括住。8、文件使用完后，未对文件进行关闭操作。9、外部输入的命令，需要做校验操作。10、将指针转换为数值时不能使用（unsing int） 应该是用（uint_ptr)。 该类型是根据CPU位宽确定。11、位运算操作时，只能对unsigned类型进行操作。12、资源泄漏。（这类问题常常为误报，但是应当从安全角度去分析代码，是否需要这个函数申请，另外一个函数去释放，如果需要，要考虑是否存在安全风险）。 pclint1、宏名重复定义。2、定义未使用的变量和函数3、圈复杂度超过15 codemars1、函数参数为数组，未传递长度。 codestyle1、未按照4字节对齐2、void *（除回调函数外，建议重新设计数据结构，以char *传递更合适）3、全局变量未加g4、函数之间使用extern变量5、宏未使用完备括号6、函数参数超过5个（这个是因为寄存器的原因，故有参数个数限制）7、函数长度超过50行（算法函数除外）8、魔鬼数字 （单独一个数字，避免过多的宏定义与不便于理解，建议使用注释注明）9、使用typdef对基本变量进行重命名。","permalink":"http://www.jacsons.com/2019/07/15/总结/思考/静态检查/","photos":[]},{"tags":[{"name":"year-plan","slug":"year-plan","permalink":"http://www.jacsons.com/tags/year-plan/"}],"title":"2019年度计划","date":"2019/07/15","text":"年度计划阅读计划 目标 一个月一本书，今年阅读完6本书并写下总结，阅读书的总体目标是linux系统，其中以驱动为切入口去了解linux中的原理。 清单 序列 书名 完成时间 状态 1 深入Linux设备驱动程序内核机制.陈学松 7月10日 100% 2 Linux C：一站式编程 7月15日 100% 3 Linux设备驱动开发详解 8月1日 100% 4 redis设计与实现 10月1日 60% 5 项目计划 目标完成ARM视频学习并编写总结，并且能够搭建一个框架含有：底层驱动、通信系统、设备管理软件、进程监控的系统设计与整理框架的搭建。 序列 任务 完成时间 状态 1 ARM视频第一期 8月1日 30% 2 ARM视频第二期 10月1日 未开始 3 ARM视频第三期 12月1日 未开始 4 整体系统的框架设计并输出文档 12月1日 未开始 5 完成框架啊代码编写 12月30日 未开始 其他目标 运动每周日一次游泳。 技能阅读每周一遍技术文档","permalink":"http://www.jacsons.com/2019/07/15/计划/2019年度计划/","photos":[]},{"tags":[{"name":"thinking","slug":"thinking","permalink":"http://www.jacsons.com/tags/thinking/"}],"title":"通用软件两年半感想之领导篇","date":"2018/09/16","text":"通用软件2年半开发经验感想 该文档是最工作两年半，在通用软件开发过程中设计的需求、开发、测试、上下游对接以及客户支撑过程中的一些注意事项以及感想。同时也对这两年半以来经历的两个PL，从他们学到的已经管理经验，做一些总结记录。 感想 这个写在最开头是因为觉得这些太重要了，相对于后面的闲言碎语，不如直接来写先写总结时刻提醒自己，在项目过程中需要注意些什么，这就是干事情的规则与条条框框。 只有用心去做好一个项目，从用户的角度去做，才能够把项目做好，自身才能更快的成长。（做好一个项目很难，做好一个让客户满意的项目更能，能够往客户方面想必然需要考虑更多，也才能学到更多） 一个项目部仅仅只有编码，还有需求分析，设计文档，编码，测试，相关人员对接，项目的编译部署，上线策略，对外影响，功能价值等方方面面。 –两年半负责开发、CIE、运维、维护工作的感想。 \b一个项目带好需要经历一年或多年，一个项目带坏只需要一个迭代就可以让你糟糕透顶。（千里之堤溃于蚁穴），\b导致人心松散，项目人员流失。 所以项目负责人一定要有责任敢，非常熟悉项目，关键时刻能够解决问题。–4个月的编排项目。 项目负责人做好一个项目除需要关注需求与story完成情况之外，需要了解客户对每个功能的要求，最后要核查开发人员对每个功能的具体实现情况，存在偏差一定要核对，避免后期造成回该成本（回改成本会是相当巨大的）–对编排收编商业洞察项目，自身没有去核对每一个功能的思考，如果没有权利修改，写出功能的不同点，并将不同点以邮件的项目发送给相关人员给出处理结论。 开发过程与处理事务过程中，遇到低效问题以及处理过程感觉别扭或者很绕的问题，一定要去思考出更好的解决方法，成长就在该过程之中。 项目中遇到不合理的事情，一定要马上更改，越到后期，修改成本越高，导致做事情的节奏越乱。– 承担维护以来的感想。 涉及对外、需要交接、问题定位一定要写好文档！减少重复沟通成本 –\b编排项目文档与FQ的减少大量沟通成本的感想。 \b \b任何事情刚刚开始处理需要相关人员配置或者影响某些人员时发一封邮件（如果时间不确定写上时间待定），处理完成之后发一封邮件。（附上纪要或者需要相关人员配合的事情，如果要有处理完事情，通知具体处理完事情），这将减少上下游处理带来的许多不必要的沟通成本。–\b负责编排框架部署任务的感想。 对外的事情，如果已经出来完，及时发信息催促相关人员处理完。 \b要做为一个项目负责人，需要了解系统的整体结构。可以通过以下几个方面去: \b\b\b阅读其他模块的代码，有条件的话最好自己去实现阅读的模块代码的功能或者写下文档。 \b可以改下其他模块代码的问题单，从而了解其他模块的功能。 了解其他模块一定先了解整个系统的骨架结构，骨架不仅仅只是本团队，而是整个产品的骨架结构。 人是必然犯错误的，思考规范步骤，从制度或者用程序来解决人常犯错的问题。–从编排框架PL所学习到的。 两个PL的思考 本节从工作两年半以来，经历过的两个PL，从他们身上\b学到能够成功作为一个PL应当需要具有哪些优秀的品质以及对自身提出的要求。两个PL之间都具有遇事不乱，\b排列出优先级耐心处理的特点。 商业洞察PL：\b在商业洞察最大的感受就是骨干问题，包括华为方与合作方。稳定结构带来的结果就是项目效果好，项目进展平稳。我觉得原因归结为以下原因合理评估工作量、尽最大努力去完成，完成不了不紧逼，\b确保团队稳定为最重要： 参与项目之中去，了解项目的功能，后期需要跟踪项目的进度无法承担功能开发，主动承担项目的一些支撑性的工作（这其实也是更好的了解项目的版本状况）。 项目工作安排以实际团队工作能够处理的事情出发，不贪大求全。 时刻与团队成员拉近关系，且让团队人员加班有一个度–这个度需要去了解相关人员工资等其他方面的竞争力。 对于一定时间内无法完成的项目，以用户交互为为主（规避方法），版本如果能够交付，则后面一个迭代估大工足量，分配一定的人员去解决规避的问题。如果不能够完成交付，能够及时知会相关人员，主动承担版本延期的责任。（尽最大努力去完成，完成不了不紧逼，\b团队稳定为最重要，敢于承担责任，而不去盲目的责怪团队成员）。 编排框架PL：在编排框架\b中对PL的感受来源于，PL本身属于经常紧急处理出问题的项目的人，其特点具有条理性，能够快速梳理出\b项目的问题点，并且能够强制执行对应的规则，将问题项目快速扭正而走向正轨，其处理过程如下： 参与项目之中，发现疑似问题点，首先找人核对并列出事情的详细步骤，思考这个步骤有很么问题，并且思考找出该步骤哪些问题，思考优化方案。（详细在仔细列出事情的各个步骤） 找出处理方案，并强制性执行。（一个新方案比来带来抵触，因为刚刚开始有抵触，但后期比来带来效率的提升。） 如果方案还有问题，及时修正再执行。（相信所有事情能够通过制度来规范，解决人常犯的错误。） 感想：如果自己做为PL或者项目负责人，首先需要去了解整体项目是干什么，然后可以从以下方面加强： 记录梳理目前需要做的事情，并给相应的事情做优先级。 根据项目情况，估计每一件事情的工作量（往大的方向估计），确认是否能够保证所有事情在deadline时间线前三天是否能够完成，如果不能够完成及时汇报风险。 根据估计的工作量，设置任务内各小点有限级，阻塞问题先处理，设置目标达成点。每日check进度情况，在每个目标达成点时情况。不要亲信说，以实际情况为准。 项目过程鼓励大家，保证大家是尽力在完成。并且识别项目进度风险，实在无法完成给出规避方案，并且记录在空闲时间及时补上正确方案。 项目过程思索效率提升点，一点点提升团队效率。 如果项目有延期风险，及时汇报，并且\b要有承担责任，\b并做总结，避免下次重蹈覆辙。 所有事情都要先列出需要哪些步骤，列出list，这样才能保证过程不被遗漏，所有人处理事情不混乱。版本管理的思考 本部分的思考。项目负责人应当如何精简项目人员，更好的管理团队做些思考。 \b一个独立的作战团队，其实不需要PL,PM,SE,SA这么多人员，PL人员可以弱化项目负责人。PM与PL合并，他们需要去了解项目的干了那些事。人员太多比来导致信息不对称成本，层级越高对项目的真实情况了解的越少，导致领导层无法了解项目的真实情况作出错误的决策。","permalink":"http://www.jacsons.com/2018/09/16/总结/思考/通用软件两年半感想/","photos":[]},{"tags":[{"name":"thinking","slug":"thinking","permalink":"http://www.jacsons.com/tags/thinking/"}],"title":"通用软件两年半感想之项目篇","date":"2018/09/09","text":"两年半感想-微服务系统 背景 写在即将离开java开发岗转向C/C++岗位之前，对这两年半从事java 微服务开发工作的uNetbuilder平台做一个总结。 微服务系统的组成 从从事的uNetbuilder的开发、维护、运维工作了解的系统以及在微信读书中阅读的书籍Paas程序设计对微服务的理解。 通过从事的微服务的工作，微服务的结构可以理解为包括以下几个部分： 业务运行系统——uNetbuilder ​ 业务系统是整个系统的核心，所有的其他结构块都是以保证该功能的正常运行。 ​ 业务运行系统即为uNetbuilder平台系统，该系统有多个解决方案构成，业务解决方案又由多个业务app构成，每个app可以构成一个作战小组，小组人员可由3-5人至10几人 构成，这样就保证了微服务能够快速编译、部署、发布响应很快。基本每个小组改动小的话，如果现网存在问题，能够在2天内进行完开发、测试、部署上线的快速响应。 ​ 单独的app（小业务块）是由多个module项目构成，我们称之为微服务。根据个人经验，一个4-5人的项目组只能支撑起6-8个微服务。微服务根据特定的业务逻辑进行划分。 ​ 每个app都有自己的Website和Service，其Website是点击app的入口，Service是website的后台服务，其主要实现两个功能：1、业务逻辑的调度—控制器功能。2、对外接口的统一管理。 ​ 整个微服务是以HSFSDK为核心进行设计的。HSFSDK类似于阿里的dubbo，采用Restful接口进行微服务与微服务之间的调用。 微服务管理系统——IService ​ 接口管理系统的功能包括以下几个功能大块： 微服务管理 ​ 微服务管理的对微服务的上线进行管理。每个业务域如果需要新增微服务，需要首先进入该系统进行登记注册，填写微服务名称、所属战队、业务类型（Wesite、Service还是SDK）。微服务的名称格式为：战队名业务功能业务类型命名。一般由版本SA进行审核，审核通过后可以获取lisence。该lisence下载下来放入该微服务下，在启动时可以完成用户微服务注册CSE。 微服务接口管理 ​ 微服务接口管理功能是对微服务与微服务之间的接口进行管理，目前uNetbuilder平台实现的微服务的管理只是对app之间进行管理，未对app之内的微服务进行管理导致微服务之内的接口比较混乱，维护与后续交接起来造成困难。 App管理功能 uNetbuilder是由多个解决方案构成的，每个解决方案下面是多个场景，场景内具有多个app。场景与场景之间存在着相同app功能。App管理功能就是为了实现记录与调整解决方案、场景、app之间关系的功能模块。 部署配套表管理系统 配套表管理系统是对场景下使用的微服务与对应的版本进行管理，其中记录了该场景需要的微服务以及对应的版本。系统的好处是便于团队依赖之间的版本进行管理，减少版本随意更改而造成的混乱，也方便部署。转测试与正式环境部署配套表为交付件就可以了。 目前微服务还有改进点：可以创建子配套表的概念，一个配套表由多个子配套表构成，由每个战队自己维护自己的子配套表。这样的好处是减少由某一个人去创建配套表的工作造成的沟通成本。 部署系统 部署系统的功能是将云龙服务——一套用户微服务编译、打包、静态检查的系统，生成的包进行部署的系统。其过程为先停止微服务运行机上的微服务并卸载，然后拷贝云龙上的包至微服务运行机器上解压、部署、数据库创建的功能。 部署过程有两种形式：按照配套表部署与按照微服务部署。 按照配套表部署 该种部署是会同步Iservice系统中创建的配套表，并自动载入选定的版本进行部署的。该种部署适用于测试环境与生产环境。 按照微服务部署 该种部署通过选择战队、微服务、版本进行部署。优点为能够针对单个微服务进行部署使用于开发环境。 部署系统还有另外一个功能环境清单的创建功能，该功能是针对Iservice中创建的配套表进行每一个微服务的运行机器的IP、Redis的配置，以及是否需要MySQL与python。创建完后会有一个环境名称。 具体的实现未去研究，通过接触的原始部署功能可以了解大概过程为：云龙打完包后可以通过ftp将包发送至ftp服务器上，部署时将包拷贝至微服务运行机器上，并部署，启动。每个过程本地都可以写shell脚本，通过统一的Restful接口去调用就可以了。 灰度管理系统 灰度管理系统的功能是为了实现业务的不间断升级功能。其中功能包括创建路由、版本设置、项目升级、app同步功能。以及在线用户查询。 项目版本路由功能：系统的整个过程为，针对每一个场景创建一个灰度路由表，其中的服务明与默认版本号来自与iService的版本，可选版本是微服务启动时注册到CSE中的版本。通过修改路由表来决定后续新建项目所走的微服务的版本号。 系统升级功能：灰度管理系统能够对已创建的项目进行升级，升级的过程是将已创建项目的版本升级至另外一个版本，升级过程中存在项目数据库的升级过程。升级包括微服务升级与项目升级。 在线用户管理：功能是通过记录在线有哪些用户来确定哪些项目不能升级。 灰度系统的整个过程是通过Redis记录每个项目所走的版本号为基础的。升级其实就是修改项目版本号信息。 运行维护系统 运维系统的功能是对所有的RDC的机器进行监控的系统，报告服务在线情况、服务稳定性、服务内存与CPU使用率、每台机器日志进行下载等维护性功能。 其中有用的是日志下载系统，能够方便获取微服务机器上的日志，而不需要登录机器去拿，减少误操作给运行机器造成不必要的麻烦。 可以优化的点，增加数据库监控系统，能够方便查询生成环境中数据库的具体内容以及具有控制权限的数据库修改。因为项目工程中有太多数据库数据异常问题需要定位，该系统可以减少开发人员维护成本。 uVoc**平台** uVoc平台用于记录用户反馈的问题，并跟踪反馈的问题的进展。 uVoc的包含两类：问题与优化需求。 问题 问题分为：建议、低问题、严重问题、致命问题。紧急程度分为：非紧急非阻塞（一个月类解决），非紧急阻塞（3天解决）、紧急阻塞（1天解决）三类。Uvoc系统跟踪每个用户问题的进展，进展包括待定位、待解决、已解决、已关闭（提问题人才能关闭）。 优化需求 需求系统记录着用户的需求，需求需要与SE、PM去对是否落实，以及何时落实。 总之，该系统主要是用户反馈声音的一个入口。 以上是2年半来从事uNetbuilder系统所理解的微服务系统的整个构成，所有的核心都是通过HSFSDK来进行连接的，HSFSDK可以理解为整个系统的血管与经络。 微服务管理、部署系统、运行维护系统、uVoc多套环境公用一个。业务运行系统、灰度系统为每个环境一个。 uNetbuilder平台的实现 商业洞察实现","permalink":"http://www.jacsons.com/2018/09/09/总结/思考/通用软件两年半感想之项目篇/","photos":[]}]}