<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于软件质量总结与思考</title>
      <link href="/2019/08/26/%E6%80%BB%E7%BB%93/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2019/08/26/%E6%80%BB%E7%BB%93/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E8%B4%A8%E9%87%8F%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>​        这段时间项目进入了迭代的尾期，主要开始处理软件质量的问题，从codestyle修改到静态检查的清理、再到安全代码检视，以及后面还有得cmetric等等。 本文是对这一阶段的工作过程中发现的codestyle、安全代码检视等各种问题做总结，另外也对项目中存在的问题做一点点思考。</p><h5 id="常见codestyle问题"><a href="#常见codestyle问题" class="headerlink" title="常见codestyle问题"></a>常见codestyle问题</h5><p>​        codestyle主要是违反公司的编码规范的问题，本节是对违反的公司编码规范的典型问题的总结。</p><ul><li>主要的问题有<br>1、四空格对齐问题<br>2、if等单条件语句未加大括号<br>3、宏定义的多行代码未加do{…}while(0)<br>4、宏定义的参数在使用过程中未添加括号。<br>5、魔鬼数字<br>6、函数超过50行<br>7、全局变量命名未添加g<br>8、变量使用不必要的初始化。</li></ul><h5 id="常见安全编码问题"><a href="#常见安全编码问题" class="headerlink" title="常见安全编码问题"></a>常见安全编码问题</h5><p>​       安全编码是根据公司的安全编码规范项对代码进行排查，本节是介绍常见违反公司安全编码规范的问题进行总结</p><ul><li><p>主要的问题有</p><p>1、日志问题</p><ul><li><p>错误状态下未打印日志</p></li><li><p>打印日志中未打印返回值</p></li><li><p>多条件打印下，日志打印不完全。</p></li></ul><p>2、数据类型使用混乱，如长度使用int(应该使用size_t). 特别注意进行位运算一定要使用无符号类型。</p><p>3、资源申请未按照要求赋初值，资源释放未赋默认值。</p><p>4、结构体类型申请未赋默认值， malloc申请内存后未使用memset_s清零.</p><p>5、函数参数在函数体类未改变，未使用const类型。</p><p>6、传入的参数为数组或字符串（const字符串除外），未传入长度。</p><p>7、对于ioctl的结果，未进行校验直接使用。</p><p>8、数据进行运算时，不考虑溢出问题。</p><p>9、if语句条件判断不完全。</p><p>10、返回值类型不统一。</p><h5 id="常见的代码问题"><a href="#常见的代码问题" class="headerlink" title="常见的代码问题"></a>常见的代码问题</h5></li></ul><p>​    在检视过程中发现项目中存在几个问题：</p><ul><li><p>项目中常见问题</p><p>1、代码中基本功能每个模块都写一份。</p><p>2、同一个文件中重复代码特别严重，基本没有考虑共同点做简化。</p><p>3、没有C++封装、低耦合高内聚思想，有些员工具有C++基本思想，但是代码写出来后将数据直接暴露出去，导致各种多线程问题频繁发出。</p><p>4、重点模块新员工写，以上几点问题代码中层出不穷，解决问题疲于奔命，直接导致项目质量持续恶化。</p></li><li><p>以上问题的几点解决办法思考</p><p>1、分析项目常用功能，编写公共组件模块，由有经验的一部分员工编写及维护。</p><p>2、赋能设计模式，提升员工低耦合高内聚思想。</p><p>3、区分项目中重点模块、复杂模块、普通模块、简单模块，由有经验的人员编写重点、复杂模块，至少完成这些模块的框架结构，新员工、新人完成普通模块与简单模块。重点、复杂模块有一老员工进行架构看护。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> conclusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>科目二考试失败总结</title>
      <link href="/2019/07/23/%E6%80%BB%E7%BB%93/%E7%A7%91%E7%9B%AE%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/23/%E6%80%BB%E7%BB%93/%E7%A7%91%E7%9B%AE%E4%BA%8C%E8%80%83%E8%AF%95%E5%A4%B1%E8%B4%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="科目二考试失败总结"><a href="#科目二考试失败总结" class="headerlink" title="科目二考试失败总结"></a>科目二考试失败总结</h4><p>　　昨天与今天备考与参加科目二考试，辛苦两天，结果科目二考试直接两把都挂在倒车入库左转弯。在平时模拟练习的过程中，一直很稳定，从未出现过倒库失败的情况。直接原因分析为一下两个方面：一、离合没有踩稳，导致车速过快压线。二、左转弯过程中，不需要打死的位置，直接打死导致左侧过窄导致左侧压线。<br>　　出现以上两个根本的原因是心态有些慌张，导致在考试过程中，第一个项目直接挂掉。<br>　　再进一步分析，根据考科目一的过程，在前几个问题考题连续出错，到10多道题目时才稳定下来。据此可以了解到这是本来的性格问题。性格问题没有办法解决，那么只有通过加强平时的训练来解决该问题。但是今天上午在加强练库的时候其他三人多次联系了倒库，而自己只联系了倒右库。<br>　　根据进一步分析得出结论，无论自己多么娴熟，在容易紧张的项目一定要在进行前，加强、加强再加强联系，千万不要掉以轻心。<br>　　再将该问题上升到生活之中，可以发现存在以下几个问题：一、懦落，不争取自己的利益（练车只倒右库）。二、办事情无逻辑。（考试进行倒库前，未理清楚路线，以及特别是中间出现的各种状况的未提前分析）。三、胆小。（考试过程中的慌张）。四、处事情太随意，未有处理事情原则(练车过程中，未对自己的方法做出总结归纳，导致联系混乱)。<br>　　针对以上问题，个人的思路：一、处事前缕清思路，考虑各种异常情况。二、平时不要蒙头做事，要大胆抬头处事。三、自己的利益一定要去争取。</p>]]></content>
      
      
      <categories>
          
          <category> conclusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conclusion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统中的互斥量</title>
      <link href="/2019/07/21/%E9%98%85%E8%AF%BB/linux/linux%E4%BA%92%E6%96%A5%E9%87%8F/"/>
      <url>/2019/07/21/%E9%98%85%E8%AF%BB/linux/linux%E4%BA%92%E6%96%A5%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="Linux系统中的互斥量"><a href="#Linux系统中的互斥量" class="headerlink" title="Linux系统中的互斥量"></a>Linux系统中的互斥量</h3><p>linux系统中所有互斥量都依赖于汇编的两个指定ldrex指定和strex指定，这两个指定都是原子指定。依赖着两个指定组成了汇编系统的并发系统的函数。</p><p>对于系统两说出现竞争的情况是：<br>1、同一CPU内的抢占导致的竞争（抢占式系统出现）<br>2、CPU与CPU之间的竞争。</p><h5 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h5><p>自旋转锁的特点是自旋转，是完全占用cpu的（只有中断才会让出本CPU）。</p><ul><li><p>基本自旋锁</p><pre><code>spin_lock &amp; spin_unlock （中断中只能使用基本的spin_lock)</code></pre><ul><li>关中断自旋锁： 自旋期间关闭中断，只关闭本cpu的中断<br>  spin_lock_irq = spin_lock + local_irq_disable<br>  spin_unlock_irq = spin_lock + local_irq_enbale</li><li>保存中断状态自旋锁 : 自旋期间关闭中断并记录中断状态，即CPSR的信息<br>  spin_lock_irqsave = spin_lock + local_irq_save<br>  spin_unlock_irqrestore = spin_lock + local_irq_restore</li><li>关下半部分中断自旋锁 ： 目前作用不明<br>  spin_lock_bh = spin_lock + local_bh_diable<br>  spin_unlock_bh = spin_lock + local_bh_enable</li><li>尝试锁<br>  spin_trylock &amp; spin_tryunlock<ul><li>典型使用<pre><code>CPU1：spin_lock_irqsave -&gt;  spin_unlock_irqrestoreCPU2: spin_lock_irqsave -&gt;  spin_unlock_irqrestore中断： spin_lock -&gt; spin_unlock</code></pre></li></ul></li></ul></li><li><p>读写自旋锁<br>写同时只能是一个，读可以并发。 读写之间是互斥的。</p><ul><li>读  read_trylock<br>  read_lock<br>  read_lock_irq<br>  read_lock_irqsave<br>  read_lock_bh</li><li>写  write_trylock<br>  write_lock<br>  write_lock_irq<br>  write_lock_irqsave<br>  write_lock_bh    </li></ul></li><li><p>顺序锁<br>写同时只能是一个，读可以并发。 读写之间是不互斥。</p><ul><li>读  read_seqtrylock<br>  read_seqlock<br>  read_seqlock_irq<br>  read_seqlock_irqsave<br>  read_seqlock_bh</li><li>写  write_seqtrylock<br>  write_seqlock<br>  write_seqlock_irq<br>  write_seqlock_irqsave<br>  write_seqlock_bh    </li></ul></li><li><p>读-复制-更新<br>RCU的有点在于可以同时存在多个读与多个写操作，但是因写操作开销大，当多个写操作过多时，会存在性能下降。建议10%左右的写，90%的读使用该类型锁。<br>RCU 不会进行互斥，是通过new新的对象，然后替换，再删除老对象的方式对内容进行保护。老队形不会立马删除，而是一种类似于java种的内存机制， RCU变量需要注册于释放，在linux系统进程切换的过程中会判断所有线程对该RCU变量的引用为0，才会调用回调函数进行内存的释放。<br>  rcu_read_lock<br>  rcu_read_unlock<br>  synchronize_rcu</p><h5 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h5><p>信号量可以0、1、n 类似java中的信号量</p></li><li><p>函数<br>  down<br>  down_interruptible : 进程能够允许被信号打断<br>  down_try_lock<br>  up</p><h5 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h5><p>互斥体与自旋锁区别是，互斥体能够让出进程进行等待，因该特性不能够在中断中使用该特性。</p></li><li><p>函数<br>  mutex_lock<br>  mutex_lock_interruptible<br>  mutex_try_lock</p></li><li><p>使用过程<br>1、 mutex_init<br>2、 mutex_lock<br>3、 mutex_unlock<br>4、 mutex_release</p><h5 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h5><p>用于一个执行单元等待另一执行单元完成某事。</p></li><li><p>函数<br>wait_for_completion<br>唤醒<br>complete<br>complete_all</p></li><li><p>使用方式<br>1、init_completion 或reinit_completion<br>2、wait_for_completion<br>3、complete 或 complete_all</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>自旋锁用于小临界去、互斥量用于大临界去（因可能让CPU休眠），其他待深入使用后补充。</p>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见静态检查问题</title>
      <link href="/2019/07/15/%E6%80%BB%E7%BB%93/%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/"/>
      <url>/2019/07/15/%E6%80%BB%E7%BB%93/%E9%9D%99%E6%80%81%E6%A3%80%E6%9F%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="常见静态检查问题"><a href="#常见静态检查问题" class="headerlink" title="常见静态检查问题"></a>常见静态检查问题</h4><p>本文介绍项目过程中常遇到的静态检查问题：</p><p>1、指针未赋值<br>2、多余的赋值。<br>3、指针加上运算未对时出现截断现象（原因是int * int  必须为long ，故因为int * long）<br>4、指针不使用时，需要赋值为NULL<br>5、文件打开时如果使用create命令，需要制定create后文件的访问权限设置。<br>6、外部输入的文件路径，需要realpath<br>7、宏定位中，输入的每一个参数都需要使用括号括住。<br>8、文件使用完后，未对文件进行关闭操作。<br>9、外部输入的命令，需要做校验操作。<br>10、将指针转换为数值时不能使用（unsing int） 应该是用（uint_ptr)。 该类型是根据CPU位宽确定。<br>11、位运算操作时，只能对unsigned类型进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> conclusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> project </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019年度计划</title>
      <link href="/2019/07/15/%E8%AE%A1%E5%88%92/2019%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
      <url>/2019/07/15/%E8%AE%A1%E5%88%92/2019%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h3 id="年度计划"><a href="#年度计划" class="headerlink" title="年度计划"></a>年度计划</h3><h4 id="阅读计划"><a href="#阅读计划" class="headerlink" title="阅读计划"></a>阅读计划</h4><ul><li><p>目标</p><p>一个月一本书，今年阅读完6本书并写下总结，阅读书的总体目标是linux系统，其中以驱动为切入口去了解linux中的原理。</p></li><li><p>清单</p></li></ul><table><thead><tr><th>序列</th><th>书名</th><th>完成时间</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>深入Linux设备驱动程序内核机制.陈学松</td><td>7月10日</td><td>100%</td></tr><tr><td>2</td><td>Linux C：一站式编程</td><td>7月15日</td><td>100%</td></tr><tr><td>3</td><td>Linux设备驱动开发详解</td><td>8月1日</td><td>100%</td></tr><tr><td>4</td><td>redis设计与实现</td><td>10月1日</td><td>40%</td></tr><tr><td>5</td><td></td><td></td><td></td></tr></tbody></table><h4 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h4><ul><li>目标<br>完成ARM视频学习并编写总结，并且能够搭建一个框架含有：底层驱动、通信系统、设备管理软件、进程监控的系统设计与整理框架的搭建。</li></ul><table><thead><tr><th>序列</th><th>任务</th><th>完成时间</th><th>状态</th></tr></thead><tbody><tr><td>1</td><td>ARM视频第一期</td><td>8月1日</td><td>30%</td></tr><tr><td>2</td><td>ARM视频第二期</td><td>10月1日</td><td>未开始</td></tr><tr><td>3</td><td>ARM视频第三期</td><td>12月1日</td><td>未开始</td></tr><tr><td>4</td><td>整体系统的框架设计并输出文档</td><td>12月1日</td><td>未开始</td></tr><tr><td>5</td><td>完成框架啊代码编写</td><td>12月30日</td><td>未开始</td></tr></tbody></table><h4 id="其他目标"><a href="#其他目标" class="headerlink" title="其他目标"></a>其他目标</h4><ul><li>运动<br>每周日一次游泳。</li><li>技能阅读<br>每周一遍技术文档</li></ul>]]></content>
      
      
      <categories>
          
          <category> plan </category>
          
      </categories>
      
      
        <tags>
            
            <tag> year-plan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>makefile学习总结</title>
      <link href="/2019/07/15/%E9%98%85%E8%AF%BB/linux/makefile/"/>
      <url>/2019/07/15/%E9%98%85%E8%AF%BB/linux/makefile/</url>
      
        <content type="html"><![CDATA[<h3 id="Makefile学习总结"><a href="#Makefile学习总结" class="headerlink" title="Makefile学习总结"></a>Makefile学习总结</h3><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h5><ul><li>变量定义<br>变量分为立即变量（:=)和延迟变量</li><li>变量使用: $()</li><li>注意事项<br>1、延迟变量展开运行时分析，编译时展开。<br>2、一般在目标、目标依赖中使用立即展开变量。<br>3、在名利中一般使用延迟变量<h5 id="目标变量"><a href="#目标变量" class="headerlink" title="目标变量"></a>目标变量</h5>1、一般变量<br>2、目标变量<br>3、</li></ul>]]></content>
      
      
      <categories>
          
          <category> learning </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用软件两年半感想之领导篇</title>
      <link href="/2018/09/16/%E6%80%BB%E7%BB%93/%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%A4%E5%B9%B4%E5%8D%8A%E6%84%9F%E6%83%B3/"/>
      <url>/2018/09/16/%E6%80%BB%E7%BB%93/%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%A4%E5%B9%B4%E5%8D%8A%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h3 id="通用软件2年半开发经验感想"><a href="#通用软件2年半开发经验感想" class="headerlink" title="通用软件2年半开发经验感想"></a>通用软件2年半开发经验感想</h3><blockquote><p>该文档是最工作两年半，在通用软件开发过程中设计的需求、开发、测试、上下游对接以及客户支撑过程中的一些注意事项以及感想。同时也对这两年半以来经历的两个PL，从他们学到的已经管理经验，做一些总结记录。</p></blockquote><h4 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h4><blockquote><p>这个写在最开头是因为觉得这些太重要了，相对于后面的闲言碎语，不如直接来写先写总结时刻提醒自己，在项目过程中需要注意些什么，这就是干事情的规则与条条框框。</p><ul><li>只有用心去做好一个项目，从用户的角度去做，才能够把项目做好，自身才能更快的成长。（做好一个项目很难，做好一个让客户满意的项目更能，能够往客户方面想必然需要考虑更多，也才能学到更多）</li></ul></blockquote><ul><li><p>一个项目部仅仅只有编码，还有需求分析，设计文档，编码，测试，相关人员对接，项目的编译部署，上线策略，对外影响，功能价值等方方面面。 –两年半负责开发、CIE、运维、维护工作的感想。</p></li><li><p>一个项目带好需要经历一年或多年，一个项目带坏只需要一个迭代就可以让你糟糕透顶。（千里之堤溃于蚁穴），导致<em>人心松散</em>，项目人员流失。 所以项目负责人一定要有责任敢，非常熟悉项目，关键时刻能够解决问题。–4个月的编排项目。</p></li><li><p>项目负责人做好一个项目除需要关注需求与story完成情况之外，需要了解客户对每个功能的要求，最后要核查开发人员对每个功能的具体实现情况，存在偏差一定要核对，避免后期造成回该成本（回改成本会是相当巨大的）–对编排收编商业洞察项目，自身没有去核对每一个功能的思考，如果没有权利修改，写出功能的不同点，并将不同点以邮件的项目发送给相关人员给出处理结论。</p></li><li><p>开发过程与处理事务过程中，遇到低效问题以及处理过程感觉别扭或者很绕的问题，一定要去思考出更好的解决方法，成长就在该过程之中。</p></li><li><p>项目中遇到不合理的事情，一定要马上更改，越到后期，修改成本越高，导致做事情的节奏越乱。– 承担维护以来的感想。</p></li><li><p>涉及对外、需要交接、问题定位一定要写好文档！减少重复沟通成本 –编排项目文档与FQ的减少大量沟通成本的感想。                  </p></li><li><p>任何事情刚刚开始处理需要相关人员配置或者影响某些人员时发一封邮件（如果时间不确定写上时间待定），处理完成之后发一封邮件。（附上纪要或者需要相关人员配合的事情，如果要有处理完事情，通知具体处理完事情），这将减少上下游处理带来的许多不必要的沟通成本。–负责编排框架部署任务的感想。</p></li><li><p>对外的事情，如果已经出来完，及时发信息催促相关人员处理完。</p></li><li><p>要做为一个项目负责人，需要了解系统的整体结构。可以通过以下几个方面去:</p><ul><li>阅读其他模块的代码，有条件的话最好自己去实现阅读的模块代码的功能或者写下文档。</li><li>可以改下其他模块代码的问题单，从而了解其他模块的功能。</li><li>了解其他模块一定先了解整个系统的骨架结构，骨架不仅仅只是本团队，而是整个产品的骨架结构。</li></ul></li><li><p>人是必然犯错误的，思考规范步骤，从制度或者用程序来解决人常犯错的问题。–从编排框架PL所学习到的。</p><h4 id="两个PL的思考"><a href="#两个PL的思考" class="headerlink" title="两个PL的思考"></a>两个PL的思考</h4><blockquote><p>本节从工作两年半以来，经历过的两个PL，从他们身上学到能够成功作为一个PL应当需要具有哪些优秀的品质以及对自身提出的要求。两个PL之间都具有遇事不乱，排列出优先级耐心处理的特点。</p></blockquote></li><li><p>商业洞察PL：<br>在商业洞察最大的感受就是骨干问题，包括华为方与合作方。稳定结构带来的结果就是项目效果好，项目进展平稳。我觉得原因归结为以下原因合理评估工作量、尽最大努力去完成，完成不了不紧逼，确保团队稳定为最重要：</p><ul><li>参与项目之中去，了解项目的功能，后期需要跟踪项目的进度无法承担功能开发，主动承担项目的一些支撑性的工作（这其实也是更好的了解项目的版本状况）。</li><li>项目工作安排以实际团队工作能够处理的事情出发，不贪大求全。</li><li>时刻与团队成员拉近关系，且让团队人员加班有一个度–这个度需要去了解相关人员工资等其他方面的竞争力。</li><li>对于一定时间内无法完成的项目，以用户交互为为主（规避方法），版本如果能够交付，则后面一个迭代估大工足量，分配一定的人员去解决规避的问题。如果不能够完成交付，能够及时知会相关人员，主动承担版本延期的责任。（尽最大努力去完成，完成不了不紧逼，团队稳定为最重要，敢于承担责任，而不去盲目的责怪团队成员）。</li></ul></li><li><p>编排框架PL：<br>在编排框架中对PL的感受来源于，PL本身属于经常紧急处理出问题的项目的人，其特点具有条理性，能够快速梳理出项目的问题点，并且能够强制执行对应的规则，将问题项目快速扭正而走向正轨，其处理过程如下：</p><ul><li>参与项目之中，发现疑似问题点，首先找人核对并列出<em>事情的详细步骤</em>，思考这个步骤有很么问题，并且思考找出该步骤哪些问题，思考优化方案。（详细在仔细列出事情的各个步骤）</li><li>找出处理方案，并强制性执行。（一个新方案比来带来抵触，因为刚刚开始有抵触，但后期比来带来效率的提升。）</li><li>如果方案还有问题，及时修正再执行。（相信所有事情能够通过制度来规范，解决人常犯的错误。）</li></ul></li><li><p>感想：如果自己做为PL或者项目负责人，首先需要去了解整体项目是干什么，然后可以从以下方面加强：</p><ul><li>记录梳理目前需要做的事情，并给相应的事情做优先级。</li><li>根据项目情况，估计每一件事情的工作量（往大的方向估计），确认是否能够保证所有事情在deadline时间线前三天是否能够完成，如果不能够完成及时汇报风险。</li><li>根据估计的工作量，设置任务内各小点有限级，阻塞问题先处理，设置目标达成点。每日check进度情况，在每个目标达成点时情况。不要亲信说，以实际情况为准。</li><li>项目过程鼓励大家，保证大家是尽力在完成。并且识别项目进度风险，实在无法完成给出规避方案，并且记录在空闲时间及时补上正确方案。</li><li>项目过程思索效率提升点，一点点提升团队效率。</li><li>如果项目有延期风险，及时汇报，并且要有承担责任，并做总结，避免下次重蹈覆辙。</li><li>所有事情都要先列出需要哪些步骤，列出list，这样才能保证过程不被遗漏，所有人处理事情不混乱。<h4 id="版本管理的思考"><a href="#版本管理的思考" class="headerlink" title="版本管理的思考"></a>版本管理的思考</h4><blockquote><p>本部分的思考。项目负责人应当如何精简项目人员，更好的管理团队做些思考。</p></blockquote></li></ul></li><li><p>一个独立的作战团队，其实不需要PL,PM,SE,SA这么多人员，PL人员可以弱化项目负责人。PM与PL合并，他们需要去了解项目的干了那些事。人员太多比来导致信息不对称成本，层级越高对项目的真实情况了解的越少，导致领导层无法了解项目的真实情况作出错误的决策。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> conclusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通用软件两年半感想之项目篇</title>
      <link href="/2018/09/09/%E6%80%BB%E7%BB%93/%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%A4%E5%B9%B4%E5%8D%8A%E6%84%9F%E6%83%B3%E4%B9%8B%E9%A1%B9%E7%9B%AE%E7%AF%87/"/>
      <url>/2018/09/09/%E6%80%BB%E7%BB%93/%E9%80%9A%E7%94%A8%E8%BD%AF%E4%BB%B6%E4%B8%A4%E5%B9%B4%E5%8D%8A%E6%84%9F%E6%83%B3%E4%B9%8B%E9%A1%B9%E7%9B%AE%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h3 id="两年半感想-微服务系统"><a href="#两年半感想-微服务系统" class="headerlink" title="两年半感想-微服务系统"></a>两年半感想-微服务系统</h3><ul><li><strong>背景</strong></li></ul><p>写在即将离开java开发岗转向C/C++岗位之前，对这两年半从事java 微服务开发工作的uNetbuilder平台做一个总结。</p><ul><li><strong>微服务系统的组成</strong></li></ul><p>从从事的uNetbuilder的开发、维护、运维工作了解的系统以及在微信读书中阅读的书籍Paas程序设计对微服务的理解。</p><p>通过从事的微服务的工作，微服务的结构可以理解为包括以下几个部分：</p><ol><li><strong>业务运行系统——uNetbuilder</strong></li></ol><p>​      业务系统是整个系统的核心，所有的其他结构块都是以保证该功能的正常运行。</p><p>​      业务运行系统即为uNetbuilder平台系统，该系统有多个解决方案构成，业务解决方案又由多个业务app构成，每个app可以构成一个作战小组，小组人员可由3-5人至10几人 构成，这样就保证了微服务能够快速编译、部署、发布响应很快。基本每个小组改动小的话，如果现网存在问题，能够在2天内进行完开发、测试、部署上线的快速响应。</p><p>​      单独的app（小业务块）是由多个module项目构成，我们称之为微服务。根据个人经验，一个4-5人的项目组只能支撑起6-8个微服务。微服务根据特定的业务逻辑进行划分。</p><p>​      每个app都有自己的Website和Service，其Website是点击app的入口，Service是website的后台服务，其主要实现两个功能：1、业务逻辑的调度—控制器功能。2、对外接口的统一管理。</p><p>​      整个微服务是以HSFSDK为核心进行设计的。HSFSDK类似于阿里的dubbo，采用Restful接口进行微服务与微服务之间的调用。</p><ol><li><strong>微服务管理系统——IService</strong></li></ol><p>​              接口管理系统的功能包括以下几个功能大块：</p><ul><li><strong>微服务管理</strong></li></ul><p>​     微服务管理的对微服务的上线进行管理。每个业务域如果需要新增微服务，需要首先进入该系统进行登记注册，填写微服务名称、所属战队、业务类型（Wesite、Service还是SDK）。微服务的名称格式为：战队名<em>业务功能</em>业务类型命名。一般由版本SA进行审核，审核通过后可以获取lisence。该lisence下载下来放入该微服务下，在启动时可以完成用户微服务注册CSE。</p><ul><li><strong>微服务接口管理</strong></li></ul><p>​       微服务接口管理功能是对微服务与微服务之间的接口进行管理，目前uNetbuilder平台实现的微服务的管理只是对app之间进行管理，未对app之内的微服务进行管理导致微服务之内的接口比较混乱，维护与后续交接起来造成困难。</p><ul><li><strong>App管理功能</strong></li></ul><p>uNetbuilder是由多个解决方案构成的，每个解决方案下面是多个场景，场景内具有多个app。场景与场景之间存在着相同app功能。App管理功能就是为了实现记录与调整解决方案、场景、app之间关系的功能模块。</p><ul><li><strong>部署配套表管理系统</strong></li></ul><p>配套表管理系统是对场景下使用的微服务与对应的版本进行管理，其中记录了该场景需要的微服务以及对应的版本。系统的好处是便于团队依赖之间的版本进行管理，减少版本随意更改而造成的混乱，也方便部署。转测试与正式环境部署配套表为交付件就可以了。</p><p>目前微服务还有改进点：可以创建子配套表的概念，一个配套表由多个子配套表构成，由每个战队自己维护自己的子配套表。这样的好处是减少由某一个人去创建配套表的工作造成的沟通成本。</p><ol><li><strong>部署系统</strong></li></ol><p>部署系统的功能是将云龙服务——一套用户微服务编译、打包、静态检查的系统，生成的包进行部署的系统。其过程为先停止微服务运行机上的微服务并卸载，然后拷贝云龙上的包至微服务运行机器上解压、部署、数据库创建的功能。</p><p>部署过程有两种形式：按照配套表部署与按照微服务部署。</p><ol><li>按照配套表部署</li></ol><p>该种部署是会同步Iservice系统中创建的配套表，并自动载入选定的版本进行部署的。该种部署适用于测试环境与生产环境。</p><ol><li>按照微服务部署</li></ol><p>该种部署通过选择战队、微服务、版本进行部署。优点为能够针对单个微服务进行部署使用于开发环境。</p><p>部署系统还有另外一个功能环境清单的创建功能，该功能是针对Iservice中创建的配套表进行每一个微服务的运行机器的IP、Redis的配置，以及是否需要MySQL与python。创建完后会有一个环境名称。</p><p>具体的实现未去研究，通过接触的原始部署功能可以了解大概过程为：云龙打完包后可以通过ftp将包发送至ftp服务器上，部署时将包拷贝至微服务运行机器上，并部署，启动。每个过程本地都可以写shell脚本，通过统一的Restful接口去调用就可以了。</p><ol><li><strong>灰度管理系统</strong></li></ol><p>灰度管理系统的功能是为了实现业务的不间断升级功能。其中功能包括创建路由、版本设置、项目升级、app同步功能。以及在线用户查询。</p><p>项目版本路由功能：系统的整个过程为，针对每一个场景创建一个灰度路由表，其中的服务明与默认版本号来自与iService的版本，可选版本是微服务启动时注册到CSE中的版本。通过修改路由表来决定后续新建项目所走的微服务的版本号。</p><p>系统升级功能：灰度管理系统能够对已创建的项目进行升级，升级的过程是将已创建项目的版本升级至另外一个版本，升级过程中存在项目数据库的升级过程。升级包括微服务升级与项目升级。</p><p>在线用户管理：功能是通过记录在线有哪些用户来确定哪些项目不能升级。</p><p>灰度系统的整个过程是通过Redis记录每个项目所走的版本号为基础的。升级其实就是修改项目版本号信息。</p><ol><li><strong>运行维护系统</strong></li></ol><p>运维系统的功能是对所有的RDC的机器进行监控的系统，报告服务在线情况、服务稳定性、服务内存与CPU使用率、每台机器日志进行下载等维护性功能。</p><p>其中有用的是日志下载系统，能够方便获取微服务机器上的日志，而不需要登录机器去拿，减少误操作给运行机器造成不必要的麻烦。</p><p>可以优化的点，增加数据库监控系统，能够方便查询生成环境中数据库的具体内容以及具有控制权限的数据库修改。因为项目工程中有太多数据库数据异常问题需要定位，该系统可以减少开发人员维护成本。</p><ol><li><strong>uVoc**</strong>平台**</li></ol><p>uVoc平台用于记录用户反馈的问题，并跟踪反馈的问题的进展。</p><p>uVoc的包含两类：问题与优化需求。</p><ol><li>问题</li></ol><p>问题分为：建议、低问题、严重问题、致命问题。紧急程度分为：非紧急非阻塞（一个月类解决），非紧急阻塞（3天解决）、紧急阻塞（1天解决）三类。Uvoc系统跟踪每个用户问题的进展，进展包括待定位、待解决、已解决、已关闭（提问题人才能关闭）。</p><ol><li>优化需求</li></ol><p>需求系统记录着用户的需求，需求需要与SE、PM去对是否落实，以及何时落实。</p><p>总之，该系统主要是用户反馈声音的一个入口。</p><p>以上是2年半来从事uNetbuilder系统所理解的微服务系统的整个构成，所有的核心都是通过HSFSDK来进行连接的，HSFSDK可以理解为整个系统的血管与经络。</p><p>微服务管理、部署系统、运行维护系统、uVoc多套环境公用一个。业务运行系统、灰度系统为每个环境一个。</p><ul><li><strong>uNetbuilder平台的实现</strong></li></ul><ul><li><strong>商业洞察实现</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> conclusion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thinking </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
